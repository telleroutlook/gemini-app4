/**\n * Secure storage utility for sensitive data like API keys\n * Uses Web Crypto API for encryption/decryption\n */\n\n// Simple encryption using Web Crypto API\nclass SecureStorage {\n  private static ALGORITHM = 'AES-GCM';\n  private static KEY_LENGTH = 256;\n  private static IV_LENGTH = 12;\n  \n  // Generate a key from user's browser fingerprint + timestamp\n  private static async generateKey(): Promise<CryptoKey> {\n    const fingerprint = await this.getBrowserFingerprint();\n    const keyMaterial = await crypto.subtle.importKey(\n      'raw',\n      new TextEncoder().encode(fingerprint),\n      'PBKDF2',\n      false,\n      ['deriveKey']\n    );\n    \n    const salt = new TextEncoder().encode('gemini-app-salt-2025');\n    \n    return crypto.subtle.deriveKey(\n      {\n        name: 'PBKDF2',\n        salt,\n        iterations: 100000,\n        hash: 'SHA-256'\n      },\n      keyMaterial,\n      {\n        name: this.ALGORITHM,\n        length: this.KEY_LENGTH\n      },\n      false,\n      ['encrypt', 'decrypt']\n    );\n  }\n  \n  // Generate a simple browser fingerprint\n  private static async getBrowserFingerprint(): Promise<string> {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d')!;\n    ctx.textBaseline = 'top';\n    ctx.font = '14px Arial';\n    ctx.fillText('Browser fingerprint', 2, 2);\n    \n    const fingerprint = [\n      navigator.userAgent,\n      navigator.language,\n      screen.width + 'x' + screen.height,\n      new Date().getTimezoneOffset(),\n      canvas.toDataURL()\n    ].join('|');\n    \n    // Hash the fingerprint\n    const encoder = new TextEncoder();\n    const data = encoder.encode(fingerprint);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    \n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n  }\n  \n  /**\n   * Encrypt and store data securely\n   */\n  static async setSecureItem(key: string, value: string): Promise<boolean> {\n    try {\n      const cryptoKey = await this.generateKey();\n      const iv = crypto.getRandomValues(new Uint8Array(this.IV_LENGTH));\n      \n      const encodedValue = new TextEncoder().encode(value);\n      \n      const encryptedData = await crypto.subtle.encrypt(\n        {\n          name: this.ALGORITHM,\n          iv\n        },\n        cryptoKey,\n        encodedValue\n      );\n      \n      // Combine IV and encrypted data\n      const combined = new Uint8Array(iv.length + encryptedData.byteLength);\n      combined.set(iv);\n      combined.set(new Uint8Array(encryptedData), iv.length);\n      \n      // Convert to base64 and store\n      const base64Data = btoa(String.fromCharCode(...combined));\n      localStorage.setItem(`secure_${key}`, base64Data);\n      \n      return true;\n    } catch (error) {\n      console.error('Failed to encrypt data:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Retrieve and decrypt data\n   */\n  static async getSecureItem(key: string): Promise<string | null> {\n    try {\n      const base64Data = localStorage.getItem(`secure_${key}`);\n      if (!base64Data) return null;\n      \n      // Convert from base64\n      const combinedData = new Uint8Array(\n        atob(base64Data).split('').map(char => char.charCodeAt(0))\n      );\n      \n      // Extract IV and encrypted data\n      const iv = combinedData.slice(0, this.IV_LENGTH);\n      const encryptedData = combinedData.slice(this.IV_LENGTH);\n      \n      const cryptoKey = await this.generateKey();\n      \n      const decryptedData = await crypto.subtle.decrypt(\n        {\n          name: this.ALGORITHM,\n          iv\n        },\n        cryptoKey,\n        encryptedData\n      );\n      \n      return new TextDecoder().decode(decryptedData);\n    } catch (error) {\n      console.error('Failed to decrypt data:', error);\n      return null;\n    }\n  }\n  \n  /**\n   * Remove secure item\n   */\n  static removeSecureItem(key: string): void {\n    localStorage.removeItem(`secure_${key}`);\n  }\n  \n  /**\n   * Check if crypto API is available\n   */\n  static isAvailable(): boolean {\n    return typeof crypto !== 'undefined' && \n           typeof crypto.subtle !== 'undefined' &&\n           typeof crypto.getRandomValues !== 'undefined';\n  }\n}\n\n/**\n * API Key Manager with security features\n */\nexport class SecureApiKeyManager {\n  private static readonly STORAGE_KEY = 'gemini_api_keys';\n  private static readonly MAX_KEYS = 10;\n  private static readonly VALIDATION_TIMEOUT = 5000;\n  \n  /**\n   * Store API keys securely\n   */\n  static async storeApiKeys(keys: string[]): Promise<boolean> {\n    if (!this.validateKeysFormat(keys)) {\n      throw new Error('Invalid API key format detected');\n    }\n    \n    // Limit number of keys\n    const limitedKeys = keys.slice(0, this.MAX_KEYS);\n    \n    if (SecureStorage.isAvailable()) {\n      const success = await SecureStorage.setSecureItem(\n        this.STORAGE_KEY, \n        JSON.stringify(limitedKeys)\n      );\n      \n      if (!success) {\n        console.warn('Secure storage failed, falling back to obfuscated storage');\n        return this.storeObfuscated(limitedKeys);\n      }\n      \n      return true;\n    } else {\n      console.warn('Crypto API not available, using obfuscated storage');\n      return this.storeObfuscated(limitedKeys);\n    }\n  }\n  \n  /**\n   * Retrieve API keys securely\n   */\n  static async retrieveApiKeys(): Promise<string[]> {\n    if (SecureStorage.isAvailable()) {\n      const secureData = await SecureStorage.getSecureItem(this.STORAGE_KEY);\n      if (secureData) {\n        try {\n          const keys = JSON.parse(secureData);\n          return Array.isArray(keys) ? keys : [];\n        } catch {\n          console.warn('Failed to parse secure keys, trying obfuscated fallback');\n        }\n      }\n    }\n    \n    // Fallback to obfuscated storage\n    return this.retrieveObfuscated();\n  }\n  \n  /**\n   * Validate API key format\n   */\n  private static validateKeysFormat(keys: string[]): boolean {\n    return keys.every(key => {\n      // Basic Gemini API key validation\n      return typeof key === 'string' && \n             key.length > 20 && \n             key.length < 200 &&\n             /^[A-Za-z0-9_-]+$/.test(key);\n    });\n  }\n  \n  /**\n   * Obfuscated storage fallback (when crypto API unavailable)\n   */\n  private static storeObfuscated(keys: string[]): boolean {\n    try {\n      const obfuscated = btoa(JSON.stringify(keys)).split('').reverse().join('');\n      localStorage.setItem(`obf_${this.STORAGE_KEY}`, obfuscated);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  \n  private static retrieveObfuscated(): string[] {\n    try {\n      const obfuscated = localStorage.getItem(`obf_${this.STORAGE_KEY}`);\n      if (!obfuscated) return [];\n      \n      const decoded = atob(obfuscated.split('').reverse().join(''));\n      const keys = JSON.parse(decoded);\n      return Array.isArray(keys) ? keys : [];\n    } catch {\n      return [];\n    }\n  }\n  \n  /**\n   * Clear all stored keys\n   */\n  static clearApiKeys(): void {\n    SecureStorage.removeSecureItem(this.STORAGE_KEY);\n    localStorage.removeItem(`obf_${this.STORAGE_KEY}`);\n  }\n  \n  /**\n   * Validate API key by making a test request\n   */\n  static async validateApiKey(key: string): Promise<boolean> {\n    try {\n      // Import dynamically to avoid loading in main bundle\n      const { GoogleGenAI } = await import('@google/genai');\n      \n      const ai = new GoogleGenAI({ apiKey: key });\n      \n      // Create a timeout promise\n      const timeoutPromise = new Promise<never>((_, reject) => {\n        setTimeout(() => reject(new Error('Validation timeout')), this.VALIDATION_TIMEOUT);\n      });\n      \n      // Test with a minimal request\n      const testPromise = ai.models.generateContent({\n        model: 'gemini-2.0-flash',\n        contents: [{ role: 'user', parts: [{ text: 'test' }] }],\n        config: { maxOutputTokens: 1 }\n      });\n      \n      await Promise.race([testPromise, timeoutPromise]);\n      return true;\n    } catch (error) {\n      console.debug('API key validation failed:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Batch validate multiple API keys\n   */\n  static async validateApiKeys(keys: string[]): Promise<boolean[]> {\n    const validationPromises = keys.map(key => this.validateApiKey(key));\n    return Promise.all(validationPromises);\n  }\n  \n  /**\n   * Get masked version of API key for display\n   */\n  static maskApiKey(key: string): string {\n    if (key.length <= 8) return '*'.repeat(key.length);\n    return `${key.slice(0, 4)}${'*'.repeat(key.length - 8)}${key.slice(-4)}`;\n  }\n}\n\n/**\n * Input sanitization utilities\n */\nexport class SecurityUtils {\n  /**\n   * Sanitize user input to prevent XSS\n   */\n  static sanitizeInput(input: string): string {\n    return input\n      .replace(/[<>\"'&]/g, (match) => {\n        const entityMap: Record<string, string> = {\n          '<': '&lt;',\n          '>': '&gt;',\n          '\"': '&quot;',\n          \"'\": '&#x27;',\n          '&': '&amp;'\n        };\n        return entityMap[match] || match;\n      })\n      .trim();\n  }\n  \n  /**\n   * Validate file uploads\n   */\n  static validateFileUpload(file: File): { valid: boolean; error?: string } {\n    const maxSize = 50 * 1024 * 1024; // 50MB\n    const allowedTypes = [\n      'text/plain',\n      'text/markdown',\n      'text/csv',\n      'application/json',\n      'image/png',\n      'image/jpeg',\n      'image/gif',\n      'image/webp',\n      'application/pdf'\n    ];\n    \n    if (file.size > maxSize) {\n      return { valid: false, error: 'File size exceeds 50MB limit' };\n    }\n    \n    if (!allowedTypes.includes(file.type)) {\n      return { valid: false, error: 'File type not allowed' };\n    }\n    \n    return { valid: true };\n  }\n  \n  /**\n   * Generate secure random string\n   */\n  static generateSecureId(length = 16): string {\n    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n      const array = new Uint8Array(length);\n      crypto.getRandomValues(array);\n      return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n    } else {\n      // Fallback for environments without crypto API\n      return Math.random().toString(36).substring(2, 2 + length);\n    }\n  }\n}